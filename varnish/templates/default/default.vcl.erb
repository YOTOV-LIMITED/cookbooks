<% @node[:varnish][:app_proxy_host].each_with_index do |host, i| %>
  backend app_server_<%= i+1 %> {
    .host = "<%= host %>";
    .port = "<%= @node[:varnish][:app_proxy_port] %>";
    .probe = {
               .url = "<%= @node[:varnish][:app_proxy_host_probe_url] %>";
               .interval = 5s;
               .timeout = 1 s;
               .window = 5;
               .threshold = 3;
    }
  }
<% end %>


backend static_server {
  .host = "<%= @node[:varnish][:static_proxy_host] %>";
  .port = "<%= @node[:varnish][:static_proxy_port] %>";
}

director app_director round-robin {
  <% @node[:varnish][:app_proxy_host].each_with_index do |host, i| %>
    { .backend = app_server_<%= i+1 %>; }
  <% end %>
}

sub vcl_recv {
    # serve slightly stale content while a fresh version is fetched
    #   better user experience and no thread pile up on the app servers
    set req.grace = 2m;
  
    # set the backend server based on request (if multi-server stack)
  <% if @node[:chef][:roles].include?('staging') %>
    set req.backend = app_server_1;
  <% elsif @node[:chef][:roles].include?('proxy') %>
    if (req.url ~ "^(/images|/javascripts|/flash|/stylesheets|/sitemaps|/articles/html|/articles/xml|/regulations/html)") {
      set req.backend = static_server;
      return (lookup);
    } else {
      set req.backend = app_director;
    }
  <% end %>
    
  
    # Reject Non-RFC2616 or CONNECT or TRACE requests.
    if (req.request != "GET" &&
      req.request != "HEAD" &&
      req.request != "PUT" &&
      req.request != "POST" &&
      req.request != "OPTIONS" &&
      req.request != "DELETE") {
        return (pipe);
    }
    
    # Compression handled upstream; only want one in the cache
    if (req.http.Accept-Encoding) {
        remove req.http.Accept-Encoding;
    }
    
    # Add a unique header containing the client address
    remove req.http.X-Forwarded-For;
    set    req.http.X-Forwarded-For = client.ip;
    
    # Pass POSTs etc directly on to the backend
    if (req.request != "GET" && req.request != "HEAD") {
        return (pass);
    }
    
    # Pass admin requests directly on to the backend
    if (req.url ~ "^/admin/") {
        return (pass);
    }

    # Remove cookies for anything that doesn't match the following
    if (req.url !~ "^(/login|/logout|/admin)") {
      unset req.http.cookie;
    }

    # Prevent duplication of caches
    set req.http.host = "<%= @node[:varnish][:proxy_host_name] %>";
    
    # Check to see if cached
    return (lookup);
}

sub vcl_fetch {
    # Remove cache headers from going out to client; cache headers are being used for
    #   varnish, not browser/upstream caches.  Eventually should replace this with a 
    #   rule that sets everything to a 5 minute cache.
    unset beresp.http.Cache-Control;
    
    # The following two sections give 'not accessible' errors...commenting out for now...
    
    # Remove cookies for anything that doesn't match the following
    # if (req.url !~ "^(/login|/logout|/admin)") {
    #   unset obj.http.set-cookie;
    # }
    
    # serve slightly stale content while a fresh version is fetched
    #    better user experience and no thread pile up on the app servers
    # set obj.grace = 2m;
    
    # Directly serve static content
    if (req.url ~ "^(/images|/javascripts|/flash|/stylesheets|/sitemaps|/articles/html|/articles/xml|/regulations/html)") {
        return(deliver);
    }
    # ESI process the rest
    else {
        esi;
    }
}


